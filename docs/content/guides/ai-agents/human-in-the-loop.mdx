---
title: Human-in-the-Loop
---

Some agent actions require human approval before proceeding - deploying to production, sending emails to customers, or making financial transactions. Workflow DevKit's webhook and hook primitives enable "human-in-the-loop" patterns where workflows pause until a human takes action.

## How It Works

<Steps>

<Step>
The agent calls a tool (like `humanApproval`) with a message describing what needs approval.
</Step>

<Step>
`createWebhook()` generates a unique URL that can resume the workflow.
</Step>

<Step>
The tool emits a data chunk containing the approval URL to the UI.
</Step>

<Step>
The workflow pauses at `await webhook` - no compute resources are consumed.
</Step>

<Step>
When a human clicks approve/reject and the webhook URL is called, the workflow resumes.
</Step>

<Step>
The tool receives any data sent with the webhook (approval status, comments) and returns.
</Step>

</Steps>

## Creating an Approval Tool

Add a tool that pauses the agent until a human approves or rejects:

<Steps>

<Step>
### Create the Emit Helper

First, create a step function to emit the approval request to the UI:

```typescript title="ai/tools/human-approval.ts" lineNumbers
import { getWritable } from 'workflow';
import type { UIMessageChunk } from 'ai';

async function emitApprovalRequest(
  { url, message }: { url: string; message: string },
  { toolCallId }: { toolCallId: string }
) {
  'use step';

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  await writer.write({
    id: toolCallId,
    type: 'data-approval-required',
    data: { url, message },
  });

  writer.releaseLock();
}
```
</Step>

<Step>
### Implement the Execute Function

The execute function creates a webhook and waits for approval:

```typescript title="ai/tools/human-approval.ts" lineNumbers
import { tool } from 'ai';
import { createWebhook } from 'workflow'; // [!code highlight]
import { z } from 'zod';

async function executeHumanApproval(
  { message }: { message: string },
  { toolCallId }: { toolCallId: string }
) {
  // Note: No "use step" - webhooks are workflow-level primitives // [!code highlight]

  const webhook = createWebhook(); // [!code highlight]

  // Emit the approval URL to the UI
  await emitApprovalRequest(
    { url: webhook.url, message },
    { toolCallId }
  );

  // Workflow pauses here until the webhook is called // [!code highlight]
  const request = await webhook; // [!code highlight]
  const { approved, comment } = await request.json(); // [!code highlight]

  if (!approved) {
    return `Action rejected: ${comment || 'No reason provided'}`;
  }

  return `Approved${comment ? ` with comment: ${comment}` : ''}`;
}

export const humanApproval = tool({
  description: 'Request human approval before proceeding with an action',
  inputSchema: z.object({
    message: z.string().describe('Description of what needs approval'),
  }),
  execute: executeHumanApproval,
});
```

<Callout type="info">
The `createWebhook()` function must be called from within a workflow context, not from a step. This is why `executeHumanApproval` does not have `"use step"`.
</Callout>
</Step>

</Steps>

## Handling the Approval UI

The UI receives a data chunk with type `data-approval-required`. Build a component that displays the approval request and handles the user's decision:

<Steps>

<Step>
### Create the Approval Component

```typescript title="components/approval-button.tsx" lineNumbers
'use client';

import { useState } from 'react';

interface ApprovalData {
  url: string;
  message: string;
}

export function ApprovalButton({ data }: { data: ApprovalData }) {
  const [comment, setComment] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isComplete, setIsComplete] = useState(false);

  const handleSubmit = async (approved: boolean) => {
    setIsSubmitting(true);
    try {
      await fetch(data.url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ approved, comment }),
      });
      setIsComplete(true);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isComplete) {
    return <div className="text-muted-foreground">Response submitted</div>;
  }

  return (
    <div className="border rounded-lg p-4 space-y-4">
      <p className="font-medium">{data.message}</p>

      <textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
        placeholder="Add a comment (optional)..."
        className="w-full border rounded p-2 text-sm"
        rows={2}
      />

      <div className="flex gap-2">
        <button
          onClick={() => handleSubmit(true)}
          disabled={isSubmitting}
          className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50"
        >
          {isSubmitting ? 'Submitting...' : 'Approve'}
        </button>
        <button
          onClick={() => handleSubmit(false)}
          disabled={isSubmitting}
          className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50"
        >
          {isSubmitting ? 'Submitting...' : 'Reject'}
        </button>
      </div>
    </div>
  );
}
```
</Step>

<Step>
### Render in Your Chat

Handle the custom data chunk type in your message renderer:

```typescript title="components/chat.tsx" lineNumbers
import { ApprovalButton } from './approval-button';

// Inside your message rendering:
{m.parts.map((part, i) => {
  if (part.type === 'text') {
    return <span key={i}>{part.text}</span>;
  }
  if (part.type === 'data-approval-required') {
    return <ApprovalButton key={i} data={part.data} />;
  }
  return null;
})}
```
</Step>

</Steps>

## Programmatic Hook Resumption

For scenarios where you need your backend code to resume a workflow (not just UI interactions), or when you want type-safe validation of approval data, use [`defineHook()`](/docs/api-reference/workflow/define-hook). This approach is useful for:

- Backend services that need to approve/reject based on business logic
- External systems that call your API to resume workflows
- Type-safe validation of approval data with Zod schemas

<Tabs items={['Hook Definition', 'Tool Implementation', 'API Route']}>

<Tab value="Hook Definition">

Define a typed hook with a Zod schema for validation:

```typescript title="ai/hooks/deployment-approval.ts" lineNumbers
import { defineHook } from 'workflow';
import { z } from 'zod';

// Export the hook so it can be used in both the tool and API routes
export const deploymentApprovalHook = defineHook({
  schema: z.object({
    approved: z.boolean(),
    approvedBy: z.string(),
    environment: z.enum(['staging', 'production']),
    notes: z.string().optional(),
  }),
});
```
</Tab>

<Tab value="Tool Implementation">

Use the hook in your tool instead of `createWebhook()`:

```typescript title="ai/tools/deployment-approval.ts" lineNumbers
import { tool } from 'ai';
import { getWritable } from 'workflow';
import { z } from 'zod';
import type { UIMessageChunk } from 'ai';
import { deploymentApprovalHook } from '../hooks/deployment-approval';

async function emitDeploymentApproval(
  token: string,
  environment: string,
  toolCallId: string
) {
  'use step';

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  await writer.write({
    id: toolCallId,
    type: 'data-deployment-approval',
    data: { token, environment },
  });

  writer.releaseLock();
}

async function executeDeploymentApproval(
  { environment }: { environment: 'staging' | 'production' },
  { toolCallId }: { toolCallId: string }
) {
  const hook = deploymentApprovalHook.create(); // [!code highlight]

  await emitDeploymentApproval(hook.token, environment, toolCallId);

  const approval = await hook; // [!code highlight]

  if (!approval.approved) {
    return `Deployment to ${environment} rejected by ${approval.approvedBy}`;
  }

  return `Deployment to ${environment} approved by ${approval.approvedBy}`;
}

export const deploymentApproval = tool({
  description: 'Request approval for a deployment',
  inputSchema: z.object({
    environment: z.enum(['staging', 'production']),
  }),
  execute: executeDeploymentApproval,
});
```
</Tab>

<Tab value="API Route">

Resume the hook from your backend API:

```typescript title="app/api/approve-deployment/route.ts" lineNumbers
import { deploymentApprovalHook } from '@/ai/hooks/deployment-approval';

export async function POST(request: Request) {
  const { token, approved, approvedBy, environment, notes } = await request.json();

  try {
    // Schema validation happens automatically // [!code highlight]
    await deploymentApprovalHook.resume(token, { // [!code highlight]
      approved,
      approvedBy,
      environment,
      notes,
    });

    return Response.json({ success: true });
  } catch (error) {
    return Response.json(
      { error: 'Invalid token or validation failed' },
      { status: 400 }
    );
  }
}
```

This API can be called by:
- Your UI components (passing the token from the data chunk)
- Backend services that need to programmatically approve/reject
- External systems via API integration
</Tab>

</Tabs>

## Use Cases

### Email Approval

Wait for approval before sending an email to customers:

```typescript lineNumbers
async function executeSendEmail(
  { recipients, subject, body }: EmailParams,
  { toolCallId }: { toolCallId: string }
) {
  const webhook = createWebhook();

  await emitEmailApproval({
    url: webhook.url,
    recipients,
    subject,
    preview: body.substring(0, 200),
  }, toolCallId);

  const request = await webhook;
  const { approved } = await request.json();

  if (!approved) {
    return 'Email cancelled by user';
  }

  await sendEmail({ recipients, subject, body });
  return `Email sent to ${recipients.length} recipients`;
}
```

### Multi-Step Approval

Chain multiple approvals for high-risk actions:

```typescript lineNumbers
export async function criticalActionWorkflow(action: string) {
  'use workflow';

  // First approval: Team lead
  const leadApproval = await requestApproval({
    role: 'team-lead',
    action,
  });

  if (!leadApproval.approved) {
    return { status: 'rejected', stage: 'team-lead' };
  }

  // Second approval: Manager
  const managerApproval = await requestApproval({
    role: 'manager',
    action,
  });

  if (!managerApproval.approved) {
    return { status: 'rejected', stage: 'manager' };
  }

  await executeCriticalAction(action);
  return { status: 'completed' };
}
```

## Complete Example

A full human approval implementation with tool and UI component:

<Tabs items={['Tool', 'UI Component']}>

<Tab value="Tool">

```typescript title="ai/tools/human-approval.ts" lineNumbers
import { tool } from 'ai';
import { createWebhook, getWritable } from 'workflow';
import { z } from 'zod';
import type { UIMessageChunk } from 'ai';

async function emitApprovalRequest(
  { url, message }: { url: string; message: string },
  { toolCallId }: { toolCallId: string }
) {
  'use step';

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  await writer.write({
    id: toolCallId,
    type: 'data-approval-required',
    data: { url, message },
  });

  writer.releaseLock();
}

async function executeHumanApproval(
  { message }: { message: string },
  { toolCallId }: { toolCallId: string }
) {
  const webhook = createWebhook();

  await emitApprovalRequest({ url: webhook.url, message }, { toolCallId });

  const request = await webhook;
  const { approved, comment } = await request.json();

  if (!approved) {
    return `Action rejected${comment ? `: ${comment}` : ''}`;
  }

  return `Approved${comment ? ` with comment: ${comment}` : ''}`;
}

export const humanApproval = tool({
  description: 'Request human approval before proceeding with an action',
  inputSchema: z.object({
    message: z.string().describe('Description of what needs approval'),
  }),
  execute: executeHumanApproval,
});
```

</Tab>

<Tab value="UI Component">

```typescript title="components/approval-button.tsx" lineNumbers
'use client';

import { useState } from 'react';

interface ApprovalData {
  url: string;
  message: string;
}

export function ApprovalButton({ data }: { data: ApprovalData }) {
  const [comment, setComment] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isComplete, setIsComplete] = useState(false);

  const handleSubmit = async (approved: boolean) => {
    setIsSubmitting(true);
    try {
      await fetch(data.url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ approved, comment }),
      });
      setIsComplete(true);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isComplete) {
    return <div className="text-muted-foreground">Response submitted</div>;
  }

  return (
    <div className="border rounded-lg p-4 space-y-4">
      <p className="font-medium">{data.message}</p>

      <textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
        placeholder="Add a comment (optional)..."
        className="w-full border rounded p-2 text-sm"
        rows={2}
      />

      <div className="flex gap-2">
        <button
          onClick={() => handleSubmit(true)}
          disabled={isSubmitting}
          className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50"
        >
          {isSubmitting ? 'Submitting...' : 'Approve'}
        </button>
        <button
          onClick={() => handleSubmit(false)}
          disabled={isSubmitting}
          className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50"
        >
          {isSubmitting ? 'Submitting...' : 'Reject'}
        </button>
      </div>
    </div>
  );
}
```

</Tab>

</Tabs>

## Related Documentation

- [Hooks & Webhooks](/docs/foundations/hooks) - Complete guide to hooks and webhooks
- [`createWebhook()` API Reference](/docs/api-reference/workflow/create-webhook) - Webhook configuration options
- [`defineHook()` API Reference](/docs/api-reference/workflow/define-hook) - Type-safe hook definitions
