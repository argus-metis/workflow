---
title: Sleep, Suspense, and Scheduling
---

AI agents sometimes need to pause execution in order to schedule recurring or future actions, wait before retrying an operation (e.g. for rate limiting), or wait for external state to be available. Workflow DevKit's [`sleep()`](/docs/api-reference/workflow/sleep) function enables Agents to pause execution without consuming compute resources, and resume at specified times.
This sleep operation survives restarts, deploys, and infrastructure changes, and the duration can span seconds, hours, days, or months.

<Callout type="info">
See the [`sleep()` API Reference](/docs/api-reference/workflow/sleep) for the full list of supported duration formats and detailed API documentation.
</Callout>

## Adding a Sleep Tool

Create a tool that allows the agent to pause for a specified duration:

<Steps>

<Step>
### Define the Tool

```typescript title="ai/tools/sleep.ts" lineNumbers
import { tool } from 'ai';
import { getWritable, sleep } from 'workflow'; // [!code highlight]
import { z } from 'zod';
import type { UIMessageChunk } from 'ai';

const inputSchema = z.object({
  durationMs: z.number().describe('Duration to sleep in milliseconds'),
});

async function reportSleep(
  { durationMs }: { durationMs: number },
  { toolCallId }: { toolCallId: string }
) {
  'use step';

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  const seconds = Math.ceil(durationMs / 1000);

  await writer.write({
    id: toolCallId,
    type: 'data-wait',
    data: { text: `Sleeping for ${seconds} seconds` },
  });

  writer.releaseLock();
}

async function executeSleep(
  { durationMs }: z.infer<typeof inputSchema>,
  { toolCallId }: { toolCallId: string }
) {
  // Note: No "use step" here - sleep is a workflow-level function // [!code highlight]

  await reportSleep({ durationMs }, { toolCallId });
  await sleep(durationMs); // [!code highlight]

  return `Slept for ${durationMs}ms`;
}

export const sleepTool = tool({
  description: 'Pause execution for a specified duration',
  inputSchema,
  execute: executeSleep,
});
```

</Step>

<Step>
### Understand the Context Requirement

The `sleep()` function must be called from within a workflow context, not from within a step. This is why `executeSleep` does not have `"use step"` - it runs in the workflow context where `sleep()` is available.
</Step>

</Steps>

## Emitting Progress Updates

When sleeping for long durations, emit a progress update so the UI can display the waiting state:

<Steps>

<Step>
### Create an Emit Helper

```typescript lineNumbers
async function emitWaitingStatus(message: string, toolCallId: string) {
  'use step';

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  await writer.write({
    id: toolCallId,
    type: 'data-wait',
    data: { text: message },
  });

  writer.releaseLock();
}
```

</Step>

<Step>
### Use in Tool Execution

```typescript lineNumbers
async function executeScheduleTask(
  { delayMinutes, taskName }: { delayMinutes: number; taskName: string },
  { toolCallId }: { toolCallId: string }
) {
  await emitWaitingStatus(
    `Scheduled "${taskName}" to run in ${delayMinutes} minutes`,
    toolCallId
  );

  await sleep(`${delayMinutes}m`); // [!code highlight]

  return `Task "${taskName}" is now ready to execute`;
}
```

</Step>

</Steps>

## Use Cases

### Rate Limiting

When hitting API rate limits, use `RetryableError` with a delay:

```typescript lineNumbers
async function callRateLimitedAPI(endpoint: string) {
  'use step';

  const response = await fetch(endpoint);

  if (response.status === 429) {
    const retryAfter = response.headers.get('Retry-After');
    throw new RetryableError('Rate limited', {
      retryAfter: retryAfter ? parseInt(retryAfter) * 1000 : '1m',
    });
  }

  return response.json();
}
```

### Polling with Backoff

Poll for a result with increasing delays:

```typescript lineNumbers
export async function pollForResult(jobId: string) {
  'use workflow';

  let attempt = 0;
  const maxAttempts = 10;

  while (attempt < maxAttempts) {
    const result = await checkJobStatus(jobId);

    if (result.status === 'complete') {
      return result.data;
    }

    attempt++;
    await sleep(Math.min(1000 * 2 ** attempt, 60000)); // Exponential backoff, max 1 minute
  }

  throw new Error('Job did not complete in time');
}

async function checkJobStatus(jobId: string) {
  'use step';
  // Check job status...
}
```

## Related Documentation

- [`sleep()` API Reference](/docs/api-reference/workflow/sleep) - Full API documentation with all duration formats
- [Workflows and Steps](/docs/foundations/workflows-and-steps) - Understanding workflow context
- [Errors and Retries](/docs/foundations/errors-and-retries) - Using `RetryableError` with delays
