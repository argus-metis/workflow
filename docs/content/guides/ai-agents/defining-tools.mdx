---
title: Defining Tool Calls
---

In Workflow DevKit, tools usually defined as [steps](/docs/foundations/workflows-and-steps). Since steps run in isolation, `DurableAgent` provides common abstractions for giving steps access to tool context. There are also some cases where tools might run inside the workflow context, as opposed to the step context, e.g. when using `sleep()` or `createWebhook()`. This guide covers the patterns and best practices for defining tools in durable agents.

## Tool Structure and Context

Workflow DevKit uses the same abstraction for tools as the AI SDK, see [the AI SDK documentation on tools](https://ai-sdk.dev/docs/foundations/tools). Here's an example tool definition:

```typescript title="ai/tools/search-web.ts" lineNumbers
import { tool } from 'ai';
import { z } from 'zod';

export const searchWeb = tool({
  description: 'Search the web for information',
  inputSchema: z.object({
    query: z.string().describe('The search query'),
    maxResults: z.number().optional().describe('Maximum number of results'),
  }),
  execute: async ({ query, maxResults = 5 }) => {
    // Tool implementation
    return { results: [] };
  },
});
```

Tools passed to `DurableAgent` are invoked with additional context. Every `execute` function receives two arguments:

1. **Input** - The validated input matching your schema
2. **Options** - Context about the tool call, including:
   - `toolCallId` - Unique identifier for this invocation
   - `messages` - The full conversation history up to and including this tool call

This allows tools to access the full conversation history through the `messages` option, which is useful when your tool needs context about what was discussed:

```typescript title="ai/tools/summarize-conversation.ts" lineNumbers
import { tool } from 'ai';
import { z } from 'zod';

export const summarizeConversation = tool({
  description: 'Summarize the conversation so far',
  inputSchema: z.object({
    focus: z.string().optional().describe('What aspect to focus on'),
  }),
  execute: async ({ focus }, { messages }) => { // [!code highlight]
    // messages contains the full LanguageModelV2Prompt
    const userMessages = messages
      .filter(m => m.role === 'user')
      .map(m => {
        // Extract text content from the message
        const textParts = m.content
          .filter(p => p.type === 'text')
          .map(p => p.text);
        return textParts.join(' ');
      });

    // Use the conversation context in your tool logic
    return {
      messageCount: messages.length,
      userMessageCount: userMessages.length,
      summary: `Conversation about: ${userMessages.slice(-3).join(', ')}`,
    };
  },
});
```

## Streaming from Tools

Tools can emit real-time updates to the UI by writing to the workflow's output stream. This must be done within a step function:

<Steps>

<Step>
### Create a Step for Stream Writes

Since `getWritable()` requires the step context, create a separate step function for emitting chunks:

```typescript lineNumbers
import { getWritable } from 'workflow';
import type { UIMessageChunk } from 'ai';

async function emitProgress(
  { status, url }: { status: string; url?: string },
  { toolCallId }: { toolCallId: string }
) {
  'use step'; // [!code highlight]

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  await writer.write({
    id: toolCallId,
    type: 'data-status',
    data: { status, url },
  });

  writer.releaseLock();
}
```

</Step>

<Step>
### Call from the Execute Function

The execute function can call this step to emit progress:

```typescript lineNumbers
async function executeSearchWeb(
  { query }: { query: string },
  { toolCallId }: { toolCallId: string }
) {
  await emitProgress({ status: 'searching', url: query }, { toolCallId }); // [!code highlight]

  const results = await performSearch(query);

  await emitProgress({ status: 'complete' }, { toolCallId }); // [!code highlight]

  return results;
}
```

</Step>

</Steps>

### Why Separate Steps?

The `getWritable()` function is only available within steps, not at the workflow level. This is because:

1. Steps provide the transactional boundary for stream writes
2. Each step's writes are persisted and can be replayed on recovery
3. The workflow context handles orchestration, not I/O

## Workflow-Level vs Step-Level Tools

Tools can run at two levels, with different capabilities:

### Step-Level Tools

When your execute function uses `"use step"`, the entire tool runs as a retryable step:

```typescript lineNumbers
async function executeWithRetries({ data }: { data: string }) {
  'use step'; // [!code highlight]

  // ✅ Can use getWritable()
  // ✅ Automatic retries on transient failures
  // ✅ Results persisted in event log
  // ❌ Cannot call sleep() or createWebhook()

  const result = await fetch(`https://api.example.com?q=${data}`);
  return result.json();
}
```

### Workflow-Level Tools

When your execute function does NOT use `"use step"`, it runs in the workflow context:

```typescript lineNumbers
async function executeWithPause({ duration }: { duration: number }) {
  // No "use step" - runs at workflow level // [!code highlight]

  // ❌ Cannot use getWritable() directly
  // ✅ Can call sleep()
  // ✅ Can call createWebhook()
  // ✅ Can call step functions

  await reportStatus('pausing'); // Step function for streaming
  await sleep(duration);         // Workflow-level function

  return 'Resumed after pause';
}
```

### Combining Both Levels

Most tools combine both approaches - use step functions for I/O and retryable operations, while keeping the execute function at the workflow level for orchestration:

```typescript title="ai/tools/fetch-with-progress.ts" lineNumbers
import { tool } from 'ai';
import { getWritable, sleep } from 'workflow';
import { z } from 'zod';
import type { UIMessageChunk } from 'ai';

// Step function: handles streaming
async function emitFetchStatus(
  { url, status }: { url: string; status: 'fetching' | 'complete' | 'retrying' },
  { toolCallId }: { toolCallId: string }
) {
  'use step';

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  await writer.write({
    id: toolCallId,
    type: 'data-fetch-status',
    data: { url, status },
  });

  writer.releaseLock();
}

// Step function: handles the actual fetch with retries
async function performFetch(url: string) {
  'use step';

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Fetch failed: ${response.status}`);
  }
  return response.json();
}

// Workflow-level execute: orchestrates steps
async function executeFetchWithProgress(
  { url }: { url: string },
  { toolCallId }: { toolCallId: string }
) {
  await emitFetchStatus({ url, status: 'fetching' }, { toolCallId });

  const result = await performFetch(url);

  await emitFetchStatus({ url, status: 'complete' }, { toolCallId });

  return result;
}

export const fetchWithProgress = tool({
  description: 'Fetch a URL and report progress',
  inputSchema: z.object({
    url: z.string().url(),
  }),
  execute: executeFetchWithProgress,
});
```

## Custom Data Chunk Types

When emitting data chunks, use descriptive type names that your UI can handle:

```typescript lineNumbers
// In your tool
await writer.write({
  id: toolCallId,
  type: 'data-run-command',  // Custom type
  data: {
    command: 'npm install',
    cwd: '/project',
  },
});

await writer.write({
  id: toolCallId,
  type: 'data-file-created',  // Another custom type
  data: {
    path: '/project/package.json',
    size: 1234,
  },
});
```

The UI handles these custom types by checking the part type:

```typescript title="components/chat.tsx" lineNumbers
{messages.map((m) => (
  <div key={m.id}>
    {m.parts.map((part, i) => {
      if (part.type === 'text') {
        return <span key={i}>{part.text}</span>;
      }
      if (part.type === 'data-run-command') {
        return (
          <div key={i} className="terminal">
            $ {part.data.command}
          </div>
        );
      }
      if (part.type === 'data-file-created') {
        return (
          <div key={i} className="file-badge">
            Created: {part.data.path}
          </div>
        );
      }
      return null;
    })}
  </div>
))}
```

## Related Documentation

- [Building Durable AI Agents](/guides/ai-agents) - Getting started with durable agents
- [Streaming](/docs/foundations/streaming) - How streaming works in Workflow DevKit
- [Workflows and Steps](/docs/foundations/workflows-and-steps) - Understanding the execution model
- [`DurableAgent` API Reference](/docs/api-reference/workflow-ai/durable-agent) - Complete API documentation
